---
title: "Outcome Item Analysis Results"
author: "Jennifer Brussow"
date: "June 26, 2017"
output: 
  pdf_document:
    keep_tex: yes
---

```{r setup, include=FALSE}
#general options
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)

source("K:/AscendKC/Corp/R_and_D/1-USERS/Jennifer Brussow/options.R")

needed_packages <- c("mirt", "ggplot2", "pander")
sapply(needed_packages, load_packages)

panderOptions('knitr.auto.asis', FALSE)

load_cuts <- c(-Inf, 0, 0.32, 0.45, 0.55, 0.63, 0.71, Inf)

# graph_colors <- c("#444444", "#65007A", "#BD5701", "#000570", "#006F7D", "#008735", "#438700")
graph_colors <- c("#A1A1A1", '#ffd57f','#c7e9b4','#7fcdbb','#41b6c4','#2c7fb8','#405AC6')

#TESTING: COMMENT OUT/DELETE FOR REAL RUN
model_fname <- "Nursing Process_analysis_result_20170630.rds"
factor_items_fname <- "Nursing Process_factor-items_20170630.rds"
results_folder <- "./Results_20170630/"

# #get data from master template
# model_fname <- model_fnames[i]
# factor_items_fname <- factor_items_fnames[i]
# results_folder <- results_folder

#load data here
model <- readRDS(paste0(results_folder, model_fname))
outcome_name <- unlist(strsplit(model_fname, "_"))[1]
factor_items <- readRDS(paste0(results_folder, factor_items_fname))

outcome_code_key <- read.csv("Outcome_codes.csv")
item_content <- read.xlsx("Best-and-worst-items_Content-from-QBTB-db.xlsx")

item_content[which(item_content$IsCorrect == 1), "responseopt"] <- 
  paste0(item_content[which(item_content$IsCorrect == 1), "responseopt"], " (c)")

item_content <- as.data.frame(apply(item_content, 2, FUN = iconv, from = "", to = "ASCII", sub=''))



newline_smart <- function(textstring, linewidth, tol = c(5, 5), capwidth = 1.2, separator = c(" ", "_")) {
  if(length(tol) > 2){
    stop("Please specify 1 or 2 values for tol.")
  }
  #makes character vector into literally a vector of characters
  lets <- unlist(strsplit(textstring, split = "")) 
  #assigns larger width values for capital characters
  widthval <- ifelse(sapply(lets, function(x) x %in% LETTERS) == TRUE, 
                     capwidth, 1) 
  #calculates the cumulative length after each character
  linelength <- cumsum(widthval) 
  #if the string is already short enough, return it
  if(linelength[length(linelength)] <= linewidth){
    return(textstring) 
  }
  
  #sets the index position to the first adj value > linewidth
  index <- Position(function(x){x < linewidth}, linelength, right = TRUE) 
  #creates a vector showing where break characters are
  breaks <- grepl(separator[1], lets) | grepl(separator[2], lets) 
  #if are two values and a break in the forward check when looking forward, NAs may be encountered. 
  #ref is the last non-NA value in the range to avoid these
  if(!is.na(tol[2]) && sum(breaks[(index+1):(index+tol[2])], na.rm = TRUE) > 0){ 
    #the last non-NA value in the forward tol
    ref <- Position(function(x){!is.na(x)}, breaks[(index+1):(index+tol[2])], right = TRUE) 
    #have to add 1 to index so we aren't evaluating it. have to subtract 1 from result to remove trailing break
    #set index to last break found in range
    index <- Position(function(x){x == TRUE}, breaks[(index+1):(index+ref)], right = TRUE)+index-1 
    #if no 2nd tol value or no breaks in forward tol, look backwards
  } else if(sum(breaks[(index-tol[1]):(index-1)], na.rm = TRUE) > 0){ 
    #have to subtract 1 from index so we aren't evaluating it. have to subtract 2 from result to remove trailing break & acct for index
    index <- index-tol[1]+Position(function(x){x == TRUE}, breaks[(index-tol[1]):(index-1)], right = TRUE)-2
  } #if neither condition is satisfied, index remains in its initial position.
  
  #put the string back together up to the index point
  out <- paste0(paste0(lets[1:index], collapse = ""), "/n", paste0(lets[(index+1):length(lets)], collapse = ""))
  
  return(out)
}

```


```{r analysis, include = FALSE}
factor_load <- summary(model)$rotF

n_factors <- ncol(factor_load)
n_items <- nrow(factor_load)

item_f_load <- vector("list", length = length(factor_items))

for(i in 1:length(item_f_load)){
  item_f_load[[i]] <- as.data.frame(factor_load[which(rownames(factor_load) %in% factor_items[[i]]),])
}

```

#Outcome Subscores: `r outcome_name`
To investigate how accurately items are assigned to outcome categories,
a series of analyses were completed to determine items' factor loadings. 

##Dataset
The dataset analyzed consisted of responses to the 2013 Comprehensive Predictor, Forms A-F, 
from test sessions that were completed between 11/15/2015 and 12/31/2015 or
04/01/2016 or 05/15/2016. All respondents were students from BSN institutions.
Pre-test items were not included. These decisions were made in order to select
a dataset that represented optimal testing conditions.

The dataset for the `r outcome_name` outcome included XXX responses to 
`r n_items` items that were tagged to the outcome. 

##Subscore plots: 

```{r plot_setup}

subscore_plots <- vector("list", n_factors)
worst_item_ids <- vector("list", n_factors)
worst_item_loads <- vector("list", n_factors)
best_item_ids <- vector("list", n_factors)
best_item_loads <- vector("list", n_factors)

for(i in 1:n_factors){
  factor_code <- colnames(factor_load)[i]
  factor_code_sub <- gsub("F", "", factor_code)
  factor_name <- unique(outcome_code_key[which(outcome_code_key$OutcomeID_map == factor_code_sub),
                                  "OutcomeDescription_map"])
  
  plot_data <- item_f_load[[i]]
  if(n_factors == 1){
    colnames(plot_data) <- factor_code
  }
  plot_data$Loading <- cut(plot_data[, factor_code], breaks = c(load_cuts))
  
  subscore_plots[[i]] <- ggplot(data = plot_data, aes_string(x = factor_code)) + 
    geom_histogram(binwidth = 0.01, aes(fill = Loading)) + 
    scale_x_continuous(limits = c(-1, 1), breaks = seq(-1, 1, .2),
                       labels = seq(-1, 1, .2)) + 
    theme_bw() +
    theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5)) +
    theme(plot.title = element_text(hjust = 0.5)) +
    labs(x = "Factor Loadings", y = "Count", 
         title = paste0(outcome_name, ": ", factor_name, " - Item Loadings"),
         caption = paste0("Mean = ", round(mean(plot_data[, factor_code]), 3),
                          ", SD = ", round(sd(plot_data[, factor_code]), 3))) +
    scale_fill_manual(values = graph_colors, 
                       labels = c("Negatively Related", "Non-Loading", "Poor", "Fair", "Good", 
                                  "Very Good", "Excellent"),
                      drop = FALSE) 
  
  
  
  worst_item_ids[[i]] <- rownames(plot_data[which.min(plot_data[, factor_code]),])
  worst_item_loads[[i]] <- round(min(plot_data[, factor_code]), 3)
  best_item_ids[[i]] <- rownames(plot_data[which.max(plot_data[, factor_code]),])
  best_item_loads[[i]] <- round(max(plot_data[, factor_code]), 3)
}

```

```{r analysis_out, results = "asis", fig.height = 6}
for(i in 1:length(subscore_plots)){
  cat("\n\n")
  cat("###Factor code: ", gsub("F", "", colnames(factor_load)[i]))
  cat("\n\n")
  cat("###Factor name: ", unique(outcome_code_key[which(outcome_code_key$OutcomeID_map == 
                                                          gsub("F", "", colnames(factor_load)[i])),
                                  "OutcomeDescription_map"]))  
  cat("\n\n")
  print(subscore_plots[[i]])
  cat("\n\n")
  cat(paste0("Worst item: ", worst_item_ids[[i]],
             ", which had a loading of ", worst_item_loads[[i]]))
  cat("\n\n")
  
  worst_item_temp <- item_content[which(item_content$QuestionID == worst_item_ids[[i]]),]
  
  worst_item_table <- matrix(NA, nrow = nrow(worst_item_temp)+1, ncol = 1)
  worst_item_table[1,] <- unique(worst_item_temp$stem)
  worst_item_table[2:5,] <- worst_item_temp$responseopt 
  
  cat("**", unique(worst_item_temp$stem), "**", "\n")
  cat("A. ", worst_item_temp[2, "responseopt"], "\n")
  cat("B. ", worst_item_temp[3, "responseopt"], "\n")
  cat("C. ", worst_item_temp[4, "responseopt"], "\n")
  cat("D. ", worst_item_temp[5, "responseopt"], "\n")
  
  cat("\n\n")
  cat(paste0("Best item: ", best_item_ids[[i]],
             ", which had a loading of ", best_item_loads[[i]]))
  cat("\n\n")
  
  best_item_temp <- item_content[which(item_content$QuestionID == best_item_ids[[i]]),]
  
  best_item_table <- matrix(NA, nrow = nrow(best_item_temp)+1, ncol = 1)
  best_item_table[1,] <- unique(best_item_temp$stem)
  best_item_table[2:5,] <- best_item_temp$responseopt
  
  print(pander(best_item_table, style = "simple", justify = "left", 
        split.table = 100, split.cells = c(100)))
  cat("\n\n")
  
  cat("***")
}
```

